# 재귀 알고리즘(Recursion Algorithm)

재귀 알고리즘은 번역에 따라 반복 알고리즘이라고도 합니다. 문제를 해결하는 데 있어서 반복적으로 처리할 때 적절한 알고리즘입니다. 재귀 알고리즘은 대부분 프로그래밍 언어(몇몇 함수형 패러다임을 따르는 언어를 제외하고)는 '반복문'이라는 문법(`while`, `for`) 등을 지원하며, 해당 문법으로 재귀 알고리즘을 충분히 구현해 낼 수 있습니다.

여기서 가리키는 재귀 알고리즘은 단순한 반복문으로 충분히 치환해 처리할 수 있는 것뿐만 아니라, 함수를 활용하여 복잡한 반복 과정을 수학적 원리를 활용하여 간단하고 깔끔하게 정리할 수 있는 것을 말합니다. 하지만, 어떤 재귀 알고리즘은 용량이 무한한 기억장치가 필요할 수 있습니다. 그러한 알고리즘은 용량이 유한한 저장장치를 사용하는 실제 컴퓨터로는 해결할 수 없을 수 있습니다.

재귀 알고리즘을 사용할 수 있는 간단한 예시로는 피보나치 수열(Fibonacci sequence)이 있습니다. 피보나치 수열은 각 단계의 수가 이전 단계의 두 수의 합으로 표현되는 수열입니다. 수식으로 일반화하면 아래와 같습니다.

$$
F_n= 
\begin{cases}
    0,                 & \text{if } n = 0 \\
    1,                 & \text{if } n = 1 \\
    F_{n-2} + F_{n-1}, & \text{if } n \gt 1
\end{cases}
$$

이때, $n$이 1보다 크면 이전 두 값을 구하는 방식이 $n$의 값을 바꾸는 것만으로도 반복적인 패턴으로 계산되는 것을 알 수 있습니다. $F_n$을 구하는 방식이 $F_{n-1}$과 $F_{n-2}$의 방식과도 일치하니 재귀적으로 해결할 수 있습니다. 코드로 표현하면 다음과 같습니다.

```c
#define FIBONACCI_BOUND 47

int fibonacci(int n) {
    if (n < 0 || n >= FIBONACCI_BOUND) {
        return -1;
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fibonacci(n - 2) + fibonacci(n - 1);
}
```

프로그램 코드를 실행하면 의도한 대로 작동하는 것을 볼 수 있습니다. 다만 이 코드를 실행하다 보면, `fibonacci` 연산에 대입하는 $n$의 값이 커질수록 실행 속도가 급격하게 느려지는 것을 확인할 수 있습니다. 32비트 정수의 표현범위는 $-2^{31}$~$2^{31}$이므로 (미리 계산해보니) $F_{46}$까지 표현할 수 있습니다.

----

[이전](./chapter001-introduction.md)

[다음](./chapter003-big-o-notation.md)
