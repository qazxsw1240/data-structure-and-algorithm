# Big-O 표기법 (Big-O notation)

알고리즘 분석에서 분석하는 대상에는 크게 두 가지 항목이 있습니다. 하나는 알고리즘을 수행하는 시간, 다른 하나는 알고리즘을 수행하는 동안 쓰이는 메모리 크기, 즉 공간입니다. 일반적으로 성능 분석을 할 때는 주로 수행 시간을 분석하게 되는데, 이는 현대 컴퓨터의 메모리가 방대해진 것도 있으며, 일반적으로 프로그램의 성능이 드러나는 것은 작업 수행 시간에 의한 것이 많기 때문입니다.

알고리즘을 분석할 때 단순하게 수행 시간을 측정하여 표현하는 방법도 있지만, 기계의 특성과 실행 환경이 실제 수행 시간에 영향을 줄 수 있습니다. 극단적인 예를 들어, 보편적인 가정의 PC로 어떤 알고리즘 A를 수행한다 가정했을 때, 1초가 걸린다고 가정합니다. 이 알고리즘을 iPhone으로 실행했을 때 0.1초가 걸린 경우, 무엇이 신뢰할 만한 수행 시간인지 확정하기 어려워집니다. 이런 상황을 고려하지 않고 알고리즘을 처리해야 하는 데이터의 수로 일반화하여  표현하는 방식이 존재합니다. 이때 해당 알고리즘의 수행 시간을 시간복잡도(time complexity), 알고리즘이 사용하는 메모리 크기를 공간 복잡도(space complexity)라고 합니다. 일반적으로 복잡도를 평가할 때 기준이 되는 것은 알고리즘이 처리하는 데이터의 개수입니다. 즉, 데이터 $n$개가 있을 때, 이 데이터 모음을 처리하는 알고리즘의 성능을 데이터 수 $n$에 대해 표현하면 세세한 실행 환경을 고려하지 않을 수 있습니다.

컴퓨터 알고리즘에서 Big-O 표기법의 목적은 정확한 계산값을 표기하는 것이 아닌, 점근 표기(asymptotic notation)로 대략적인 성능을 표현하는 데에 있습니다. Big-O 표기법을 작성하는 데에 있어서 정확한 계산 이후에 점근식으로 변환하는 방법도 있고, 점근식의 특징을 활용해, 점근식의 합성으로 표현하고는 합니다.

복잡도를 계산할 때 최상, 평균, 최악 이렇게 세 항목으로 나눕니다. Big-O 표기법은 최악의 경우를 다루는데, 최상일 때의 복잡도는 최상일 때의 조건을 갖추기가 실제로 어렵거나 일반화하여 계산하기 어려우며, 평균은 최상과 최악 두 경우의 사잇값을 나타내고, 마찬가지로 계산하기가 어려운 경우가 많아 최악일 때의 경우를 많이 활용합니다. 그리고 최악의 경우를 염두에 두는 것은 최상일 때와 평균일 때의 최저 성능을 보장한다는 뜻이기도 합니다.

Big-O 표기법은 수학적인 정의로 다음과 같습니다.

> 실수나 복소수에서 정의된 함수 $f$가 존재하며, 실수에서 정의된 함수 $g$가 존재한다. 함수 $f$와 $g$는 양의 실수 구간에서 유계가 없는 부분 집합(unbounded subset)에서 정의돼야 하며, 함수 $g(x)$는 충분히 큰 실수 $x$에 대해서 항상 양수여야 한다.
>
> 식 $f(x)=O(g(x))$을 만족하려면 임의의 양의 실수 $M$과 $x_0$에 대해서 다음을 만족한다.
>
> $$|f(x)| \leq Mg(x) \text{ for all } x \geq x_0$$

연습 삼아, $f(x)=x^2+3x+4$와 $g(x)=x^2$가 존재할 때, $f(x)=O(g(x))$를 만족하는지 확인해 봅시다. 정의대로 Big-O 표기법을 풀어 쓰면, 임의의 양의 실수 $x_0$에 대해서 구간 $x \geq x_0$에서 항상 $|f(x) \leq Mg(x)|$를 만족하는 양의 실수 $M$이 존재하면 됩니다. 이때 $x_0 = 1$로 설정하면 $M=8$로 조건을 만족합니다. 따라서 $f(x)=O(g(x))$으로 표현할 수 있습니다.

이러한 수학적 정의를 바탕으로 Big-O 표기법으로 표현되는 시간복잡도를 간략하게 설명하면 크게 다음의 전제와 규칙으로 표현합니다.

- 데이터 개수 $n$은 충분히 크다.
- 복잡도는 데이터 개수 $n$에 대한 다항식으로 표현된다.
- 복잡도의 최고차항을 제외하고 생략한다.
- 최고차항의 계수는 생략한다.

정의대로라면, $O(2n)$이나 $O(0.5n-2)$ 모두 $O(n)$으로 표현됩니다. 두 성능은 대략 4배 정도의 차이를 내지만 Big-O 표기법에선 같은 성능으로 인식되므로, 이 표기법이 실제 정확한 성능을 비교하기엔 어려운 점이 있다는 것을 알 수 있습니다. 다음은 일반적인 Big-O 표기법에 적힌 성능 비교표입니다. $n$에 대한 $N$ 값이 작을수록 좋은 성능임을 나타냅니다.


![Big-O Notation Comparison](https://upload.wikimedia.org/wikipedia/commons/7/7e/Comparison_computational_complexity.svg)
이미지 출처: 위키피디아(Big O Notation)

그래프를 참고하면 다음과 같은 비교 관계가 성립합니다.

$$
O(1) \leq O(\log n) \leq O(\sqrt n) \leq O(n) \leq O(n \log n) \leq O(n^2) \leq O(2^n) \leq O(n!)
$$

다시 코드로 돌아와서, 기존의 코드의 성능을 분석해 볼 수 있습니다.

```c
int fibonacci(int n) {
    // ...
    return fibonacci(n - 2) + fibonacci(n - 1);
}
```

기존의 재귀 호출 방식을 살펴 보면, `fibonacci(n - 1)`은 `fibonacci(n - 2)`를 계산한 것을 포함하고 있습니다. 즉, `fibonacci(n)`은 `fibonacci(n - 2)`을 두 번 계산합니다. 따라서 `n`이 1씩 증가할 때마다 계산량은 두 배 늘어나므로 시간복잡도는 대략 $2^{n-2}$이니 Big-O 표기법으로 $O(2^n)$가 됨을 알 수 있습니다. 이를 개선하려면, 같은 값을 두 번 계산하는 과정을 생략하는 게 좋아 보입니다. 그렇다면 미리 계산한 값을 알아야 합니다. 코드로 구현하면 다음과 같습니다.

```c
int fibonacci(n) {
    int previous = 0;
    int current = 1;
    for (int i = 0; i < n; ++i) {
        int temp = current;
        int current = current + prev;
        int prev = temp;
    }
    return current;
}
```

`fibonacci(n - 2)`와 `fibonacci(n - 1)`이 지역 변수 `previous`와 `current에` 잠시 저장돼 의도한 대로 연산 중에 값이 유지되는 것을 볼 수 있습니다. 이렇게 구현하면 시간복잡도는 $n-2$가 되므로 Big-O 표기법으로 $O(n)$이므로 차수를 많이 내릴 수 있습니다.

충분히 연산 속도는 빨라졌지만, 계산값이 연산 중에만 기억되어 활용됩니다. 중간 과정 값을 함수를 호출할 때마다 새로 연산을 하는 것보다 함수가 호출할 때 계산된 중간 과정 값이 알고리즘 종료 후에도 계속 유지되면 더 빠른 연산을 기대할 수 있습니다.

```c
#define FIBONACCI_BOUND 47

int fibonacci(int n) {
    static int initialized = 0;
    static int memo[FIBONACCI_BOUND];

    if (n < 0 || n >= FIBONACCI_BOUND) {
        return -1;
    }

    if (initialized == 0) {
        for (int i = 0; i < FIBONACCI_BOUND; ++i) {
            if (i == 0) {
                memo[i] = 0;
            } else if (i == 1) {
                memo[i] = 1;
            } else {
                memo[i] = -1;
            }
        }
    }

    if (memo[n] == -1) {
        memo[n] = fibonacci(n - 2) + fibonacci(n - 1);
    }

    return memo[n];
}
```

피보나치 수열의 결괏값을 배열에 저장하는 방식으로 결괏값을 함수가 호출한 뒤에서 중간 결괏값을 기억할 수 있게 했습니다. 피보나치 수열은 0이상의 정수로 표현되기에 -1을 초기화되지 않았다는 상태를 나타내는 값으로 활용하였습니다. 중간 결과 값이 계산돼 있다면(-1이 아니라면) 그 값을 반환하고, 그렇지 않다면 재귀적으로 중간 결과 값이 있는 배열의 값을 읽어가면서 새로 계산된 값이 있다면 배열에 계산한 값을 채우며 연산을 수행합니다. 이렇게 구현하면 단순히 결괏값만 기억되는 것뿐만 아니라 결괏값을 도출하는 과정의 모든 중간 결과 값이 모두 기억됩니다. 4바이트 int 자료형으로 표현 가능한 범위까지 가능한 모든 피보나치 수열을 계산했을 때 상당히 결과가 빨리 나오는 것을 확인할 수 있습니다. 이 알고리즘의 시간복잡도는 $O(n)$이지만, 실제로는 한 번 계산한 것이 계속 활용되므로 연산을 계속할수록 $O(1)$의 성능을 발휘합니다.

----

[이전](./chapter002-recursion-algorithm.md)
